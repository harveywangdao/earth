第1章 深入Go语言编译器 1
1．1 为什么要了解Go语言编译器 1
1．2 Go语言编译器的阶段 1
1．3 词法解析 3
1．4 语法解析 4
1．5 抽象语法树构建 6
1．6 类型检查 8
1．7 变量捕获 8
1．8 函数内联 9
1．9 逃逸分析 12
1．10 闭包重写 14
1．11 遍历函数 15
1．12 SSA生成 15
1．13 机器码生成――汇编器 18
1．14 机器码生成――链接 20
1．15 ELF文件解析 23
1．16 总结 26
第2章 浮点数设计原理与使用方法 27
2．1 浮点数陷阱 27
2．2 定点数与浮点数 27
2．3 IEEE-754浮点数标准 28
2．3．1 小数部分计算 29
2．3．2 显示浮点数格式 30
2．4 最佳实践：判断浮点数为整数 31
2．5 常规数与非常规数 33
2．6 NaN与Inf 33
2．7 浮点数精度 34
2．8 浮点数与格式化打印 36
2．9 浮点数计算与精度损失 37
2．10 多精度浮点数与math/big库 38
2．11 总结 41
第3章 类型推断全解析 42
3．1 类型推断的优势 42
3．2 Go语言中类型推断的特性 43
3．3 类型推断原理 44
3．3．1 词法解析与语法分析阶段 44
3．3．2 抽象语法树生成与类型检查 46
3．4 总结 48
第4章 常量与隐式类型转换 49
4．1 常量声明与生存周期 49
4．2 常量类型转换 50
4．2．1 隐式整数转换 50
4．2．2 隐式浮点数转换 51
4．2．3 常量运算中的隐式转换 51
4．2．4 常量与变量之间的转换 51
4．2．5 自定义类型的转换 52
4．3 常量与隐式类型转换原理 53
4．4 总结 55
第5章 字符串本质与实现 56
5．1 字符串的本质 56
5．2 符文类型 57
5．3 字符串工具函数 58
5．4 字符串底层原理 59
5．4．1 字符串解析 59
5．4．2 字符串拼接 61
5．4．3 运行时字符拼接 62
5．4．4 字符串与字节数组的转换 64
5．5 总结 66
第6章 数组 67
6．1 数组的声明方式 67
6．2 数组值复制 68
6．3 数组底层原理 68
6．3．1 编译时数组解析 68
6．3．2 数组字面量初始化原理 69
6．3．3 数组字面量编译时内存优化 70
6．3．4 数组索引与访问越界原理 70
6．4 总结 73
第7章 切片使用方法与底层原理 74
7．1 切片使用方法 74
7．1．1 切片的结构 74
7．1．2 切片的初始化 75
7．1．3 切片的截取 75
7．1．4 切片值复制与数据引用 76
7．1．5 切片收缩与扩容 77
7．2 切片底层原理 78
7．2．1 字面量初始化 78
7．2．2 make初始化 79
7．2．3 切片扩容原理 80
7．2．4 切片截取原理 82
7．2．5 切片的完整复制 83
7．3 总结 84
第8章 哈希表与Go实现机制 85
8．1 哈希碰撞与解决方法 85
8．2 map基本操作 87
8．2．1 map声明与初始化 87
8．2．2 map访问 87
8．2．3 map赋值 88
8．2．4 key的比较性 88
8．2．5 map并发冲突 89
8．3 哈希表底层结构 89
8．4 哈希表原理图解 91
8．5 深入哈希表原理 94
8．5．1 make初始化原理 94
8．5．2 字面量初始化原理 96
8．5．3 map访问原理 97
8．5．4 map赋值操作原理 99
8．5．5 map重建原理 102
8．5．6 map删除原理 103
8．6 总结 104
第9章 函数与栈 105
9．1 函数基本使用方式 105
9．2 函数闭包与陷阱 106
9．3 函数栈 107
9．4 Go语言栈帧结构 108
9．5 Go语言函数调用链结构与特性 110
9．6 堆栈信息 111
9．7 栈扩容与栈转移原理 113
9．8 栈调试 118
9．9 总结 120
第10章 defer延迟调用 121
10．1 使用的defer的优势 122
10．1．1 资源释放 122
10．1．2 异常捕获 123
10．2 defer特性 125
10．2．1 延迟执行 125
10．2．2 参数预计算 126
10．2．3 defer多次执行与LIFO执行顺序 127
10．3 defer返回值陷阱 127
10．4 defer底层原理 129
10．4．1 defer演进 129
10．4．2 堆分配 130
10．4．3 defer遍历调用 134
10．4．4 Go 1．13栈分配优化 137
10．4．5 Go 1．14内联优化 138
10．5 总结 140
第11章 异常与异常捕获 141
11．1 panic函数使用方法 141
11．2 异常捕获与recover 142
11．3 panic与recover嵌套 144
11．4 panic函数底层原理 145
11．5 recover底层原理 149
11．6 总结 152
第12章 接口与程序设计模式 154
12．1 接口的用途 154
12．2 Go语言中的接口 155
12．3 Go接口实践 156
12．4 Go接口的使用方法 158
12．4．1 Go接口的声明与定义 158
12．4．2 接口实现 159
12．4．3 接口动态类型 160
12．4．4 接口的动态调用 161
12．4．5 多接口 162
12．4．6 接口的组合 162
12．4．7 接口类型断言 163
12．4．8 空接口 164
12．4．9 接口的比较性 166
12．5 接口底层原理 166
12．5．1 接口实现算法 166
12．5．2 接口组成 168
12．5．3 接口内存逃逸分析 171
12．5．4 接口动态调用过程 173
12．5．5 接口动态调用过程的效率评价 177
12．5．6 接口转换 182
12．5．7 空接口组成 184
12．5．8 空接口switch 187
12．5．9 接口的陷阱 189
12．6 总结 191
第13章 反射高级编程 192
13．1 为什么需要反射 193
13．2 反射的基本使用方法 195
13．2．1 反射的两种基本类型 195
13．2．2 反射转换为接口 196
13．2．3 Elem()间接访问 197
13．2．4 修改反射的值 199
13．2．5 结构体与反射 200
13．2．6 遍历结构体字段 200
13．2．7 修改结构体字段 201
13．2．8 嵌套结构体的赋值 202
13．2．9 结构体方法与动态调用 203
13．2．10 反射在运行时创建结构体 205
13．2．11 函数与反射 206
13．2．12 反射与其他类型 206
13．3 反射底层原理 207
13．3．1 reflect．Type详解 207
13．3．2 Interface方法原理 209
13．3．3 Int方法原理 211
13．3．4 Elem方法释疑 211
13．3．5 动态调用剖析 213
13．4 总结 216
第14章 协程初探 217
14．1 进程与线程 217
14．2 线程上下文切换 219
14．3 线程与协程 220
14．3．1 调度方式 220
14．3．2 上下文切换的速度 220
14．3．3 调度策略 221
14．3．4 栈的大小 221
14．4 并发与并行 221
14．5 简单协程入门 222
14．6 main协程与子协程 223
14．7 GMP模型 225
14．8 总结 226
第15章 深入协程设计与调度原理 227
15．1 协程的生命周期与状态转移 227
15．2 特殊协程g0与协程切换 228
15．3 线程本地存储与线程绑定 230
15．4 调度循环 231
15．5 调度策略 232
15．5．1 获取本地运行队列 234
15．5．2 获取全局运行队列 235
15．5．3 获取准备就绪的网络协程 236
15．5．4 协程窃取 237
15．6 调度时机 238
15．6．1 主动调度 238
15．6．2 被动调度 239
15．6．3 抢占调度 241
15．6．4 执行时间过长的抢占调度 241
15．7 总结 247
第16章 通道与协程间通信 248
16．1 CSP并发编程 248
16．2 通道基本使用方式 249
16．2．1 通道声明与初始化 249
16．2．2 channel写入数据 250
16．2．3 通道读取数据 250
16．2．4 通道关闭 250
16．2．5 通道作为参数和返回值 252
16．2．6 单方向通道 253
16．2．7 通道最佳实践 254
16．3 select多路复用 258
16．3．1 select随机选择机制 258
16．3．2 select堵塞与控制 259
16．3．3 循环select 260
16．3．4 select 与nil 261
16．4 通道底层原理 261
16．4．1 通道结构与环形队列 261
16．4．2 通道初始化 263
16．4．3 通道写入原理 263
16．4．4 通道读取原理 265
16．5 select底层原理 267
16．5．1 select一轮循环 269
16．5．2 select二轮循环 270
16．6 总结 271
第17章 并发控制 272
17．1 context 272
17．1．1 为什么需要Context 272
17．1．2 Context使用方式 274
17．2 context原理 277
17．3 数据争用检查 280
17．3．1 什么是数据争用 280
17．3．2 数据争用检查详解 282
17．3．3 race工具原理 282
17．4 锁 286
17．4．1 原子锁 287
17．4．2 互斥锁 289
17．4．3 互斥锁实现原理 290
17．4．4 互斥锁的释放 294
17．4．5 读写锁 295
17．4．6 读写锁原理 296
17．5 总结 298
第18章 内存分配管理 299
18．1 Go语言内存分配全局视野 299
18．1．1 span与元素 299
18．1．2 三级对象管理 300
18．1．3 四级内存块管理 301
18．2 对象分配 302
18．2．1 微小对象 302
18．2．2 mcache缓存位图 304
18．2．3 mcentral遍历span 305
18．2．4 mheap缓存查找 307
18．2．5 mheap基数树查找 307
18．2．6 操作系统内存申请 311
18．2．7 小对象分配 311
18．2．8 大对象分配 312
18．3 总结 312
第19章 垃圾回收初探 313
19．1 为什么需要垃圾回收 314
19．1．1 减少错误和复杂性 314
19．1．2 解耦 314
19．2 垃圾回收的5种经典算法 315
19．2．1 标记-清扫 315
19．2．2 标记-压缩 316
19．2．3 半空间复制 316
19．2．4 引用计数 317
19．2．5 分代GC 318
19．3 Go语言中的垃圾回收 318
19．3．1 为什么不选择压缩GC？ 319
19．3．2 为什么不选择分代GC？ 319
19．4 Go垃圾回收演进 319
19．5 总结 321
第20章 深入垃圾回收全流程 322
20．1 垃圾回收循环 322
20．2 标记准备阶段 323
20．2．1 计算标记协程的数量 323
20．2．2 切换到后台标记协程 325
20．3 并发标记阶段 325
20．3．1 根对象扫描 327
20．3．2 全局变量扫描 328
20．3．3 finalizer 330
20．3．4 栈扫描 331
20．3．5 栈对象 332
20．3．6 扫描灰色对象 333
20．4 标记终止阶段 336
20．5 辅助标记 339
20．6 屏障技术 341
20．7 垃圾清扫 347
20．7．1 懒清扫逻辑 348
20．7．2 辅助清扫 349
20．8 系统驻留内存清除 350
20．9 实战：垃圾回收产生的性能问题 352
20．10 总结 354
第21章 调试利器：特征分析与事件追踪 355
21．1 pprof的使用方式 355
21．1．1 堆内存特征分析 357
21．1．2 pprof可视化结果说明 360
21．1．3 pprof协程栈分析 361
21．1．4 base基准分析 362
21．1．5 mutex堵塞分析 363
21．1．6 CPU占用分析 363
21．2 火焰图分析 365
21．3 trace事件追踪 366
21．3．1 trace工具的用法与说明 366
21．3．2 trace 分析场景 369
21．4 pprof底层原理 370
21．4．1 堆内存样本 370
21．4．2 协程栈样本收集原理 372
21．4．3 CPU样本收集原理 372
21．4．4 pprof分析原理 375
21．5 trace底层原理 377
21．6 总结 379
